"""
Cryptographic Models Module

This module defines the core cryptographic models used throughout the TopoSphere system.
These models represent the cryptographic structures, operations, and analysis results
that form the foundation of ECDSA security assessment.

The models are designed to be shared between client and server components, ensuring
consistent interpretation of cryptographic data across the system.

Key components:
- ECDSA signature structure and validation
- Key representation and analysis models
- Nonce generation and security assessment
- Cryptographic analysis results
- Security metrics and vulnerability indicators

This module works in conjunction with topological_models.py, providing the cryptographic
foundation upon which topological analysis is built.

Version: 1.0.0
"""

from __future__ import annotations
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Tuple, Optional, Any, Union, Protocol, TypeVar, Generic
import numpy as np
from datetime import datetime
import hashlib
from collections import defaultdict

# ======================
# ENUMERATIONS
# ======================

class ECDSACurve(Enum):
    """Supported elliptic curve types."""
    SECP256K1 = "secp256k1"
    NIST_P256 = "P-256"
    NIST_P384 = "P-384"
    NIST_P521 = "P-521"
    ED25519 = "Ed25519"
    UNKNOWN = "unknown"


class SignatureSource(Enum):
    """Source of signatures in analysis."""
    REAL = "real"  # Actual signatures from implementation
    SYNTHETIC = "synthetic"  # Generated for analysis
    MIXED = "mixed"  # Combination of real and synthetic
    GENERATED = "generated"  # Generated by our system for testing


class NonceGenerationMethod(Enum):
    """Methods of nonce generation in ECDSA implementations."""
    RFC6979 = "RFC6979"  # Deterministic nonce generation
    RANDOM = "random"  # Standard random generation
    WEAK_PRNG = "weak_prng"  # Implementation with weak PRNG
    LCG = "lcg"  # Linear Congruential Generator
    CTR_DRBG = "ctr_drbg"  # NIST SP 800-90A compliant
    HMAC_DRBG = "hmac_drbg"  # NIST SP 800-90A compliant
    UNKNOWN = "unknown"


class KeySecurityLevel(Enum):
    """Security level of cryptographic keys based on analysis."""
    SECURE = "secure"  # No detected vulnerabilities
    CAUTION = "caution"  # Minor issues detected, but not critical
    VULNERABLE = "vulnerable"  # Significant vulnerabilities detected
    CRITICAL = "critical"  # High probability of key recovery
    UNKNOWN = "unknown"  # Insufficient data for assessment


class CryptographicAnalysisStatus(Enum):
    """Status of cryptographic analysis results."""
    SUCCESS = "success"
    PARTIAL = "partial"  # Some analyses completed, others failed
    FAILED = "failed"
    INCONCLUSIVE = "inconclusive"  # Insufficient data for definitive conclusion
    INVALID_KEY = "invalid_key"  # Key validation failed


# ======================
# DATA CLASSES
# ======================

@dataclass(frozen=True)
class ECDSASignature:
    """ECDSA signature data structure used throughout TopoSphere.
    
    Represents a complete ECDSA signature with metadata for analysis.
    
    The structure includes both the standard signature components (r, s, z) and
    the topological parameters (u_r, u_z) that enable topological analysis.
    """
    r: int
    s: int
    z: int
    u_r: int
    u_z: int
    is_synthetic: bool = False
    confidence: float = 1.0
    source: SignatureSource = SignatureSource.REAL
    timestamp: Optional[float] = None
    meta: Dict[str, Any] = field(default_factory=dict)
    
    @classmethod
    def from_real_signature(cls, 
                           r: int, 
                           s: int, 
                           z: int, 
                           curve_order: int) -> ECDSASignature:
        """Create signature from real ECDSA signature.
        
        Args:
            r, s, z: Standard ECDSA signature components
            curve_order: Order of the elliptic curve subgroup
            
        Returns:
            ECDSASignature: Signature with estimated topological parameters
        """
        # In a real implementation, would estimate u_r and u_z from r, s, z
        # This is a placeholder for demonstration
        return cls(
            r=r,
            s=s,
            z=z,
            u_r=r % curve_order,
            u_z=z % curve_order,
            is_synthetic=False,
            confidence=1.0,
            source=SignatureSource.REAL,
            timestamp=datetime.now().timestamp()
        )
    
    @classmethod
    def generate_synthetic(cls, 
                          public_key: Any, 
                          curve: Any, 
                          u_r: int, 
                          u_z: int) -> ECDSASignature:
        """Generate synthetic signature for analysis.
        
        As proven in Theorem 19 of our research, for any public key Q = dG and
        for any pair (u_r, u_z) ∈ ℤ_n × ℤ_n, there exists a signature (r, s, z).
        
        This method implements that theorem, generating signatures without knowledge
        of the private key.
        
        Args:
            public_key: ECDSA public key
            curve: Elliptic curve parameters
            u_r, u_z: Topological parameters
            
        Returns:
            ECDSASignature: Synthetic signature for analysis
        """
        # Compute R = (u_r * Q + u_z * G)
        R = (u_r * public_key) + (u_z * curve.G)
        r = R.x() % curve.n
        
        # Choose s arbitrarily (e.g., 1)
        s = 1
        
        # Compute z = s * u_z mod n
        z = (s * u_z) % curve.n
        
        return cls(
            r=r,
            s=s,
            z=z,
            u_r=u_r,
            u_z=u_z,
            is_synthetic=True,
            confidence=1.0,
            source=SignatureSource.SYNTHETIC,
            meta={"synthetic_method": "topological_generation"}
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "r": self.r,
            "s": self.s,
            "z": self.z,
            "u_r": self.u_r,
            "u_z": self.u_z,
            "is_synthetic": self.is_synthetic,
            "confidence": self.confidence,
            "source": self.source.value,
            "timestamp": self.timestamp,
            "meta": self.meta
        }


@dataclass
class KeyAnalysisResult:
    """Result of cryptographic key analysis.
    
    Contains comprehensive analysis of a cryptographic key's security properties.
    """
    public_key: str
    curve: ECDSACurve
    security_level: KeySecurityLevel
    vulnerability_score: float
    nonce_generation_method: NonceGenerationMethod
    analysis_timestamp: float = field(default_factory=lambda: datetime.now().timestamp())
    signatures_analyzed: int = 0
    synthetic_signatures_generated: int = 0
    topological_metrics: Dict[str, float] = field(default_factory=dict)
    cryptographic_metrics: Dict[str, float] = field(default_factory=dict)
    detected_vulnerabilities: List[Dict[str, Any]] = field(default_factory=list)
    status: CryptographicAnalysisStatus = CryptographicAnalysisStatus.SUCCESS
    error_message: Optional[str] = None
    
    @property
    def is_secure(self) -> bool:
        """Determine if the key is secure based on analysis."""
        return self.security_level in [KeySecurityLevel.SECURE, KeySecurityLevel.CAUTION]
    
    @property
    def vulnerability_level(self) -> str:
        """Categorize vulnerability level for reporting."""
        if self.vulnerability_score >= 0.7:
            return "critical"
        elif self.vulnerability_score >= 0.4:
            return "high"
        elif self.vulnerability_score >= 0.2:
            return "medium"
        elif self.vulnerability_score >= 0.1:
            return "low"
        else:
            return "secure"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "public_key": self.public_key,
            "curve": self.curve.value,
            "security_level": self.security_level.value,
            "vulnerability_score": self.vulnerability_score,
            "nonce_generation_method": self.nonce_generation_method.value,
            "analysis_timestamp": self.analysis_timestamp,
            "signatures_analyzed": self.signatures_analyzed,
            "synthetic_signatures_generated": self.synthetic_signatures_generated,
            "topological_metrics": self.topological_metrics,
            "cryptographic_metrics": self.cryptographic_metrics,
            "detected_vulnerabilities": self.detected_vulnerabilities,
            "status": self.status.value,
            "error_message": self.error_message,
            "vulnerability_level": self.vulnerability_level
        }


@dataclass
class NonceSecurityAssessment:
    """Assessment of nonce generation security.
    
    Analyzes the security properties of nonce generation in an ECDSA implementation.
    """
    entropy_estimate: float
    uniformity_score: float
    symmetry_violation_rate: float
    spiral_consistency: float
    diagonal_consistency: float
    vulnerability_indicators: List[str] = field(default_factory=list)
    security_level: KeySecurityLevel = KeySecurityLevel.UNKNOWN
    
    @classmethod
    def analyze_from_signatures(cls, 
                               signatures: List[ECDSASignature], 
                               curve_order: int) -> NonceSecurityAssessment:
        """Analyze nonce security from signature data.
        
        Args:
            signatures: List of ECDSA signatures
            curve_order: Order of the elliptic curve subgroup
            
        Returns:
            NonceSecurityAssessment: Assessment of nonce generation security
        """
        if not signatures:
            return cls(
                entropy_estimate=0.0,
                uniformity_score=0.0,
                symmetry_violation_rate=1.0,
                spiral_consistency=0.0,
                diagonal_consistency=0.0,
                security_level=KeySecurityLevel.UNKNOWN
            )
        
        # Calculate entropy estimate
        # Implementation would calculate actual entropy
        entropy_estimate = 0.8  # Placeholder
        
        # Calculate uniformity score
        # Implementation would analyze distribution
        uniformity_score = 0.9  # Placeholder
        
        # Check symmetry violations
        symmetry_violations = 0
        total = 0
        for sig in signatures:
            # In real implementation, would check if r(u_r, u_z) == r(u_z, u_r)
            total += 1
        symmetry_violation_rate = symmetry_violations / total if total > 0 else 1.0
        
        # Check spiral consistency
        # Implementation would analyze spiral pattern
        spiral_consistency = 0.95  # Placeholder
        
        # Check diagonal consistency
        # Implementation would analyze diagonal pattern
        diagonal_consistency = 0.9  # Placeholder
        
        # Determine security level
        if symmetry_violation_rate > 0.1 or spiral_consistency < 0.7:
            security_level = KeySecurityLevel.CRITICAL
        elif symmetry_violation_rate > 0.05 or spiral_consistency < 0.85:
            security_level = KeySecurityLevel.VULNERABLE
        elif symmetry_violation_rate > 0.01 or spiral_consistency < 0.95:
            security_level = KeySecurityLevel.CAUTION
        else:
            security_level = KeySecurityLevel.SECURE
        
        # Identify vulnerability indicators
        indicators = []
        if symmetry_violation_rate > 0.01:
            indicators.append("symmetry_violation")
        if spiral_consistency < 0.95:
            indicators.append("spiral_pattern_anomaly")
        if diagonal_consistency < 0.9:
            indicators.append("diagonal_periodicity")
        
        return cls(
            entropy_estimate=entropy_estimate,
            uniformity_score=uniformity_score,
            symmetry_violation_rate=symmetry_violation_rate,
            spiral_consistency=spiral_consistency,
            diagonal_consistency=diagonal_consistency,
            vulnerability_indicators=indicators,
            security_level=security_level
        )
    
    @property
    def vulnerability_score(self) -> float:
        """Calculate overall vulnerability score for nonce generation."""
        # Weighted combination of metrics
        return (
            0.3 * (1.0 - self.uniformity_score) +
            0.25 * self.symmetry_violation_rate +
            0.2 * (1.0 - self.spiral_consistency) +
            0.15 * (1.0 - self.diagonal_consistency) +
            0.1 * (1.0 - min(self.entropy_estimate, 1.0))
        )


@dataclass
class CryptographicAnalysisResult:
    """Comprehensive result of cryptographic analysis.
    
    Combines topological and cryptographic analysis for a complete security assessment.
    """
    status: CryptographicAnalysisStatus
    public_key: str
    curve: ECDSACurve
    signatures_analyzed: int
    synthetic_signatures_generated: int
    topological_analysis: Dict[str, Any]
    cryptographic_analysis: Dict[str, Any]
    security_level: KeySecurityLevel
    vulnerability_score: float
    recommendations: List[str] = field(default_factory=list)
    execution_time: float = 0.0
    timestamp: float = field(default_factory=lambda: datetime.now().timestamp())
    
    @property
    def is_secure(self) -> bool:
        """Determine if the implementation is secure based on combined analysis."""
        return self.security_level in [KeySecurityLevel.SECURE, KeySecurityLevel.CAUTION]
    
    @property
    def vulnerability_level(self) -> str:
        """Categorize vulnerability level for reporting."""
        if self.vulnerability_score >= 0.7:
            return "critical"
        elif self.vulnerability_score >= 0.4:
            return "high"
        elif self.vulnerability_score >= 0.2:
            return "medium"
        elif self.vulnerability_score >= 0.1:
            return "low"
        else:
            return "secure"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "status": self.status.value,
            "public_key": self.public_key,
            "curve": self.curve.value,
            "signatures_analyzed": self.signatures_analyzed,
            "synthetic_signatures_generated": self.synthetic_signatures_generated,
            "topological_analysis": self.topological_analysis,
            "cryptographic_analysis": self.cryptographic_analysis,
            "security_level": self.security_level.value,
            "vulnerability_score": self.vulnerability_score,
            "vulnerability_level": self.vulnerability_level,
            "recommendations": self.recommendations,
            "execution_time": self.execution_time,
            "timestamp": self.timestamp
        }
    
    @classmethod
    def from_components(cls,
                       topological_result: Dict[str, Any],
                       crypto_result: Dict[str, Any],
                       public_key: str,
                       curve: ECDSACurve) -> CryptographicAnalysisResult:
        """Create combined analysis result from component analyses.
        
        Args:
            topological_result: Result of topological analysis
            crypto_result: Result of cryptographic analysis
            public_key: Public key being analyzed
            curve: Elliptic curve used
            
        Returns:
            CryptographicAnalysisResult: Combined analysis result
        """
        # Calculate overall vulnerability score
        vulnerability_score = (
            0.6 * topological_result.get("vulnerability_score", 0.0) +
            0.4 * crypto_result.get("vulnerability_score", 0.0)
        )
        
        # Determine security level
        if vulnerability_score >= 0.7:
            security_level = KeySecurityLevel.CRITICAL
        elif vulnerability_score >= 0.4:
            security_level = KeySecurityLevel.VULNERABLE
        elif vulnerability_score >= 0.2:
            security_level = KeySecurityLevel.CAUTION
        else:
            security_level = KeySecurityLevel.SECURE
        
        # Generate recommendations
        recommendations = []
        if security_level == KeySecurityLevel.CRITICAL:
            recommendations.append("URGENT: High probability of private key leakage. Rotate address immediately.")
        elif security_level == KeySecurityLevel.VULNERABLE:
            recommendations.append("HIGH RISK: Vulnerability detected. Consider rotating address soon.")
        elif security_level == KeySecurityLevel.CAUTION:
            recommendations.append("CAUTION: Minor issues detected. Monitor usage and consider rotation.")
        
        # Add specific recommendations based on detected issues
        if topological_result.get("is_torus_structure", False) is False:
            recommendations.append("Topology does not match expected torus structure (β₁ ≠ 2.0)")
        if topological_result.get("symmetry_violation_rate", 1.0) > 0.01:
            recommendations.append("High symmetry violation rate detected (>1%)")
        if crypto_result.get("entropy_estimate", 1.0) < 0.5:
            recommendations.append("Low entropy in nonce generation detected")
        
        return cls(
            status=CryptographicAnalysisStatus.SUCCESS,
            public_key=public_key,
            curve=curve,
            signatures_analyzed=topological_result.get("signatures_analyzed", 0),
            synthetic_signatures_generated=topological_result.get("synthetic_signatures_generated", 0),
            topological_analysis=topological_result,
            cryptographic_analysis=crypto_result,
            security_level=security_level,
            vulnerability_score=min(vulnerability_score, 1.0),
            recommendations=recommendations
        )


@dataclass
class AddressRotationRecommendation:
    """Recommendation for address rotation based on usage patterns.
    
    Provides mathematically grounded recommendations for when to rotate cryptographic addresses.
    """
    current_transaction_count: int
    optimal_rotation_point: int
    recommended_action: str
    confidence: float
    risk_probability: float
    time_to_rotation: Optional[float] = None  # In transactions
    security_degradation_rate: float = 0.0
    last_analysis_timestamp: float = field(default_factory=lambda: datetime.now().timestamp())
    
    @classmethod
    def calculate(cls,
                 transaction_count: int,
                 vulnerability_score: float,
                 security_model: Dict[str, float]) -> AddressRotationRecommendation:
        """Calculate address rotation recommendation.
        
        Uses the model P_vuln(m) = 1 - e^(-λm) to determine optimal rotation point.
        
        Args:
            transaction_count: Current number of transactions for this address
            vulnerability_score: Current vulnerability score (0-1)
            security_model: Parameters of the security degradation model
            
        Returns:
            AddressRotationRecommendation: Recommendation for address rotation
        """
        # Extract model parameters
        lambda_param = security_model.get("lambda", 0.01)
        risk_threshold = security_model.get("risk_threshold", 0.05)
        
        # Calculate current risk probability
        risk_probability = 1.0 - np.exp(-lambda_param * transaction_count)
        
        # Calculate optimal rotation point (m* = argmin_m {c·m + L·P_vuln(m)})
        # Simplified for this example
        optimal_rotation = int(np.log(1 - risk_threshold) / -lambda_param)
        
        # Determine recommended action
        if transaction_count >= 0.9 * optimal_rotation:
            action = "URGENT_ROTATION"
            confidence = 0.99
        elif transaction_count >= 0.7 * optimal_rotation:
            action = "CONSIDER_ROTATION"
            confidence = 0.95
        else:
            action = "CONTINUE_USING"
            confidence = 0.90
        
        # Calculate time to rotation (in transactions)
        time_to_rotation = optimal_rotation - transaction_count if transaction_count < optimal_rotation else 0
        
        # Calculate security degradation rate
        degradation_rate = lambda_param * np.exp(-lambda_param * transaction_count)
        
        return cls(
            current_transaction_count=transaction_count,
            optimal_rotation_point=optimal_rotation,
            recommended_action=action,
            confidence=confidence,
            risk_probability=risk_probability,
            time_to_rotation=time_to_rotation,
            security_degradation_rate=degradation_rate
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "current_transaction_count": self.current_transaction_count,
            "optimal_rotation_point": self.optimal_rotation_point,
            "recommended_action": self.recommended_action,
            "confidence": self.confidence,
            "risk_probability": self.risk_probability,
            "time_to_rotation": self.time_to_rotation,
            "security_degradation_rate": self.security_degradation_rate,
            "last_analysis_timestamp": self.last_analysis_timestamp
        }


# ======================
# PROTOCOLS AND INTERFACES
# ======================

T = TypeVar('T')
class CryptoProtocol(Protocol, Generic[T]):
    """Base protocol for cryptographic operations."""
    
    def generate_key_pair(self) -> T:
        """Generate a new cryptographic key pair."""
        ...
    
    def sign(self, message: bytes, private_key: T) -> ECDSASignature:
        """Sign a message using the private key."""
        ...
    
    def verify(self, message: bytes, signature: ECDSASignature, public_key: T) -> bool:
        """Verify a signature using the public key."""
        ...
    
    def analyze_security(self, public_key: T, signatures: List[ECDSASignature]) -> CryptographicAnalysisResult:
        """Analyze the security of a public key and its signatures."""
        ...


class ECDSACryptoProtocol(CryptoProtocol[Any]):
    """Protocol for ECDSA cryptographic operations."""
    
    def estimate_private_key(self, 
                            public_key: Any, 
                            signatures: List[ECDSASignature]) -> Optional[int]:
        """Estimate the private key from signatures.
        
        Args:
            public_key: ECDSA public key
            signatures: List of ECDSA signatures
            
        Returns:
            Estimated private key or None if not possible
        """
        ...
    
    def detect_nonce_reuse(self, signatures: List[ECDSASignature]) -> List[Dict[str, Any]]:
        """Detect nonce reuse vulnerabilities.
        
        Args:
            signatures: List of ECDSA signatures
            
        Returns:
            List of detected nonce reuse instances
        """
        ...
    
    def analyze_nonce_distribution(self, 
                                  signatures: List[ECDSASignature], 
                                  curve_order: int) -> Dict[str, Any]:
        """Analyze the distribution of nonces in signatures.
        
        Args:
            signatures: List of ECDSA signatures
            curve_order: Order of the elliptic curve subgroup
            
        Returns:
            Analysis of nonce distribution properties
        """
        ...


class KeyRotationProtocol(Protocol):
    """Protocol for address rotation recommendations."""
    
    def calculate_optimal_rotation(self, 
                                 transaction_count: int, 
                                 vulnerability_score: float) -> AddressRotationRecommendation:
        """Calculate optimal address rotation point.
        
        Args:
            transaction_count: Current number of transactions
            vulnerability_score: Current vulnerability score (0-1)
            
        Returns:
            AddressRotationRecommendation: Recommendation for address rotation
        """
        ...
    
    def get_risk_probability(self, transaction_count: int) -> float:
        """Get the probability of vulnerability at given transaction count.
        
        Args:
            transaction_count: Number of transactions
            
        Returns:
            Probability of vulnerability
        """
        ...
    
    def get_security_degradation_rate(self, transaction_count: int) -> float:
        """Get the rate of security degradation at given transaction count.
        
        Args:
            transaction_count: Number of transactions
            
        Returns:
            Security degradation rate
        """
        ...


# ======================
# HELPER FUNCTIONS
# ======================

def validate_public_key(public_key: str, curve: ECDSACurve) -> bool:
    """Validate a public key for the specified curve.
    
    Args:
        public_key: Public key in hex format
        curve: Elliptic curve type
        
    Returns:
        bool: True if valid, False otherwise
    """
    # Implementation would validate the public key
    # This is a simplified placeholder
    if not public_key:
        return False
    
    # Check format based on curve
    if curve == ECDSACurve.SECP256K1:
        # secp256k1 public keys are 33 or 65 bytes (66 or 130 hex chars) with prefix
        if public_key.startswith(('02', '03', '04')) and len(public_key) in (66, 130):
            return True
    elif curve in [ECDSACurve.NIST_P256, ECDSACurve.NIST_P384, ECDSACurve.NIST_P521]:
        # NIST curves have similar format requirements
        if public_key.startswith(('02', '03', '04')) and len(public_key) in (66, 130, 198):
            return True
    
    return False


def estimate_private_key_from_signatures(signatures: List[ECDSASignature]) -> Optional[float]:
    """Estimate private key security based on signature analysis.
    
    Args:
        signatures: List of ECDSA signatures
        
    Returns:
        Estimated private key security metric or None
    """
    if not signatures:
        return None
    
    # Implementation would estimate private key security
    # This is a simplified placeholder
    return 0.8  # Placeholder value


def calculate_vulnerability_score(topological_metrics: Dict[str, float], 
                                crypto_metrics: Dict[str, float]) -> float:
    """Calculate overall vulnerability score from multiple metrics.
    
    Args:
        topological_metrics: Metrics from topological analysis
        crypto_metrics: Metrics from cryptographic analysis
        
    Returns:
        Combined vulnerability score (0-1)
    """
    # Weighted combination of metrics
    topological_score = (
        0.3 * topological_metrics.get("betti_deviation", 0.0) +
        0.25 * (1.0 - topological_metrics.get("topological_entropy", 1.0)) +
        0.2 * (1.0 - topological_metrics.get("uniformity_score", 1.0)) +
        0.25 * topological_metrics.get("symmetry_violation", 1.0)
    )
    
    crypto_score = (
        0.4 * (1.0 - crypto_metrics.get("entropy_estimate", 1.0)) +
        0.3 * crypto_metrics.get("symmetry_violation_rate", 1.0) +
        0.2 * (1.0 - crypto_metrics.get("spiral_consistency", 1.0)) +
        0.1 * (1.0 - crypto_metrics.get("diagonal_consistency", 1.0))
    )
    
    # Combined score (weighted average)
    return 0.6 * topological_score + 0.4 * crypto_score


def generate_synthetic_signatures(public_key: Any, 
                                curve: Any, 
                                num_samples: int = 1000) -> List[ECDSASignature]:
    """Generate synthetic signatures for analysis.
    
    As proven in Theorem 19, for any public key Q = dG and for any pair (u_r, u_z),
    there exists a signature (r, s, z). This method implements that theorem.
    
    Args:
        public_key: ECDSA public key
        curve: Elliptic curve parameters
        num_samples: Number of signatures to generate
        
    Returns:
        List[ECDSASignature]: Generated synthetic signatures
    """
    signatures = []
    for _ in range(num_samples):
        u_r = np.random.randint(0, curve.n)
        u_z = np.random.randint(0, curve.n)
        signatures.append(ECDSASignature.generate_synthetic(public_key, curve, u_r, u_z))
    return signatures


def analyze_nonce_security(signatures: List[ECDSASignature], 
                         curve_order: int) -> NonceSecurityAssessment:
    """Analyze the security of nonce generation from signatures.
    
    Args:
        signatures: List of ECDSA signatures
        curve_order: Order of the elliptic curve subgroup
        
    Returns:
        NonceSecurityAssessment: Assessment of nonce generation security
    """
    return NonceSecurityAssessment.analyze_from_signatures(signatures, curve_order)


def calculate_optimal_rotation_point(transaction_count: int, 
                                  vulnerability_score: float) -> AddressRotationRecommendation:
    """Calculate optimal address rotation point based on usage.
    
    Uses the model P_vuln(m) = 1 - e^(-λm) to determine optimal rotation point.
    
    Args:
        transaction_count: Current number of transactions
        vulnerability_score: Current vulnerability score (0-1)
        
    Returns:
        AddressRotationRecommendation: Recommendation for address rotation
    """
    # Security model parameters
    security_model = {
        "lambda": 0.01 * vulnerability_score,  # Higher vulnerability increases lambda
        "risk_threshold": 0.05
    }
    
    return AddressRotationRecommendation.calculate(
        transaction_count,
        vulnerability_score,
        security_model
    )


def is_key_secure(vulnerability_score: float, 
                 transaction_count: int, 
                 optimal_rotation: int) -> bool:
    """Determine if a key is currently secure based on usage.
    
    Args:
        vulnerability_score: Current vulnerability score (0-1)
        transaction_count: Current number of transactions
        optimal_rotation: Optimal rotation point
        
    Returns:
        bool: True if key is secure, False otherwise
    """
    # Key is secure if vulnerability score is low and we're below optimal rotation
    return vulnerability_score < 0.2 and transaction_count < 0.8 * optimal_rotation
